import debounce from 'debounce-promise';
import { subscribe as _subscribe } from '@parcel/watcher';
import parseGitIgnore from 'parse-gitignore';
import path from 'path';
import fs from 'fs';
import _open from 'open';
// EventEmitter is a class name and expected to have PascalCase
// eslint-disable-next-line @typescript-eslint/naming-convention
import EventEmitter from 'events';
import { GetParameterCommand, ParameterNotFound, SSMServiceException, } from '@aws-sdk/client-ssm';
import { AmplifyPrompter, LogLevel, format, } from '@aws-amplify/cli-core';
import { createFilesChangesTracker, } from './files_changes_tracker.js';
import { AmplifyError, AmplifyUserError, BackendIdentifierConversions, } from '@aws-amplify/platform-core';
import { EOL } from 'os';
/**
 * CDK stores bootstrap version in parameter store. Example parameter name looks like /cdk-bootstrap/<qualifier>/version.
 * The default value for qualifier is hnb659fds, i.e. default parameter path is /cdk-bootstrap/hnb659fds/version.
 * The default qualifier is hardcoded value without any significance.
 * Ability to provide custom qualifier is intended for name isolation between automated tests of the CDK itself.
 * In order to use custom qualifier all stack synthesizers must be programmatically configured to use it.
 * That makes bootstraps with custom qualifier incompatible with Amplify Backend and we treat that setup as
 * not bootstrapped.
 * See: https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html
 */
export const CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME = 
// suppress spell checker, it is triggered by qualifier value.
// eslint-disable-next-line spellcheck/spell-checker
'/cdk-bootstrap/hnb659fds/version';
export const CDK_MIN_BOOTSTRAP_VERSION = 6;
/**
 * Constructs Amplify Console bootstrap URL for a given region
 * @param region AWS region
 * @returns Amplify Console bootstrap URL
 */
export const getBootstrapUrl = (region) => `https://${region}.console.aws.amazon.com/amplify/create/bootstrap?region=${region}`;
/**
 * Runs a file watcher and deploys
 */
export class FileWatchingSandbox extends EventEmitter {
    backendIdSandboxResolver;
    executor;
    ssmClient;
    functionsLogStreamer;
    printer;
    open;
    subscribe;
    watcherSubscription;
    outputFilesExcludedFromWatch = ['.amplify'];
    filesChangesTracker;
    /**
     * Creates a watcher process for this instance
     */
    constructor(backendIdSandboxResolver, executor, ssmClient, functionsLogStreamer, printer, open = _open, subscribe = _subscribe) {
        process.once('SIGINT', () => void this.stop());
        process.once('SIGTERM', () => void this.stop());
        super();
        this.backendIdSandboxResolver = backendIdSandboxResolver;
        this.executor = executor;
        this.ssmClient = ssmClient;
        this.functionsLogStreamer = functionsLogStreamer;
        this.printer = printer;
        this.open = open;
        this.subscribe = subscribe;
    }
    /**
     * @inheritdoc
     */
    emit(eventName, ...args) {
        return super.emit(eventName, ...args);
    }
    /**
     * @inheritdoc
     */
    on(eventName, listener) {
        return super.on(eventName, listener);
    }
    /**
     * @inheritdoc
     */
    start = async (options) => {
        const watchDir = options.dir ?? './amplify';
        const watchForChanges = options.watchForChanges ?? true;
        if (!fs.existsSync(watchDir)) {
            throw new AmplifyUserError('PathNotFoundError', {
                message: `${watchDir} does not exist.`,
                resolution: 'Make sure you are running this command from your project root directory.',
            });
        }
        this.filesChangesTracker = await createFilesChangesTracker(watchDir);
        const bootstrapped = await this.isBootstrapped();
        // get region from an available sdk client;
        const region = await this.ssmClient.config.region();
        if (!bootstrapped) {
            this.printer.log(`The region ${format.highlight(region)} has not been bootstrapped. Sign in to the AWS console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.${EOL}If this is not the region you are expecting to bootstrap, check for any AWS environment variables that may be set in your shell or use ${format.command('--profile <profile-name>')} to specify a profile with the correct region.`);
            const bootstrapUrl = getBootstrapUrl(region);
            try {
                await this.open(bootstrapUrl);
            }
            catch (e) {
                // If opening the link fails for any reason we fall back to
                // printing the url in the console.
                // This might happen:
                // - in headless environments
                // - if user does not have any app to open URL
                // - if browser crashes
                let logEntry = 'Unable to open bootstrap url';
                if (e instanceof Error) {
                    logEntry = `${logEntry}, ${e.message}`;
                }
                this.printer.log(logEntry, LogLevel.DEBUG);
                this.printer.log(`Open ${bootstrapUrl} in the browser.`);
            }
            return;
        }
        const ignoredPaths = this.getGitIgnoredPaths();
        this.outputFilesExcludedFromWatch =
            this.outputFilesExcludedFromWatch.concat(...ignoredPaths);
        await this.printSandboxNameInfo(options.identifier);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------    file changed     --------------    file changed     --------------  file changed
        // |      | ------------------> |            | ------------------> |            | --------------|
        // | open |                     | deploying  |                     |   queued   |               |
        // |      | <------------------ |            | <------------------ |            | <-------------|
        // --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'open';
        const deployAndWatch = debounce(async () => {
            latch = 'deploying';
            // Stop streaming the logs so that deployment logs don't get mixed up
            this.functionsLogStreamer.stopStreamingLogs();
            await this.deploy(options);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits' ¯\_(ツ)_/¯,
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                this.printer.log("[Sandbox] Detected file changes while previous deployment was in progress. Invoking 'sandbox' again");
                await this.deploy(options);
            }
            latch = 'open';
            // Idle state, let customers know and start streaming function logs
            this.emitWatching();
            await this.functionsLogStreamer.startStreamingLogs(await this.backendIdSandboxResolver(options.identifier), options.functionStreamingOptions);
        });
        if (watchForChanges) {
            this.watcherSubscription = await this.subscribe(watchDir, async (_, events) => {
                // Log and track file changes.
                await Promise.all(events.map(({ type: eventName, path }) => {
                    this.filesChangesTracker.trackFileChange(path);
                    this.printer.log(`[Sandbox] Triggered due to a file ${eventName} event: ${path}`);
                }));
                if (latch === 'open') {
                    await deployAndWatch();
                }
                else {
                    // this means latch is either 'deploying' or 'queued'
                    latch = 'queued';
                    this.printer.log('[Sandbox] Previous deployment is still in progress. ' +
                        'Will queue for another deployment after this one finishes');
                }
            }, {
                ignore: this.outputFilesExcludedFromWatch.concat(...(options.exclude ?? [])),
            });
            // Start the first full deployment without waiting for a file change
            await deployAndWatch();
        }
        else {
            await this.deploy(options);
        }
    };
    /**
     * @inheritdoc
     */
    stop = async () => {
        this.printer.log(`[Sandbox] Shutting down`, LogLevel.DEBUG);
        this.functionsLogStreamer?.stopStreamingLogs();
        // can be undefined if command exits before subscription
        await this.watcherSubscription?.unsubscribe();
    };
    /**
     * @inheritdoc
     */
    delete = async (options) => {
        this.printer.log('[Sandbox] Deleting all the resources in the sandbox environment...');
        await this.executor.destroy(await this.backendIdSandboxResolver(options.identifier), options.profile);
        this.emit('successfulDeletion');
        this.printer.log('[Sandbox] Finished deleting.');
    };
    shouldValidateAppSources = () => {
        const snapshot = this.filesChangesTracker.getAndResetSnapshot();
        // if zero files changed this indicates initial deployment
        const shouldValidateOnColdStart = snapshot.hadTypeScriptFilesAtStart &&
            !snapshot.didAnyFileChangeSinceStart;
        return (shouldValidateOnColdStart ||
            snapshot.didAnyTypeScriptFileChangeSinceLastSnapshot);
    };
    deploy = async (options) => {
        try {
            const deployResult = await this.executor.deploy(await this.backendIdSandboxResolver(options.identifier), 
            // It's important to pass this as callback so that debounce does
            // not reset tracker prematurely
            this.shouldValidateAppSources, options.profile);
            this.printer.log('[Sandbox] Deployment successful', LogLevel.DEBUG);
            this.emit('successfulDeployment', deployResult);
        }
        catch (error) {
            // Print a meaningful message
            this.printer.print(format.error(this.getErrorMessage(error)));
            this.emit('failedDeployment', error);
            // If the error is because of a non-allowed destructive change such as
            // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-aliasattributes
            // offer to recreate the sandbox or revert the change
            if (AmplifyError.isAmplifyError(error) &&
                error.name === 'CFNUpdateNotSupportedError') {
                await this.handleUnsupportedDestructiveChanges(options);
            }
            // else do not propagate and let the sandbox continue to run
        }
    };
    reset = async (options) => {
        await this.delete({ identifier: options.identifier });
        await this.start(options);
    };
    /**
     * Just a shorthand console log to indicate whenever watcher is going idle
     */
    emitWatching = () => {
        this.printer.log(`[Sandbox] Watching for file changes...`);
    };
    /**
     * Reads and parses .gitignore file and returns the list of paths
     */
    getGitIgnoredPaths = () => {
        const gitIgnoreFilePath = path.join(process.cwd(), '.gitignore');
        if (fs.existsSync(gitIgnoreFilePath)) {
            return parseGitIgnore
                .parse(gitIgnoreFilePath)
                .patterns.map((pattern) => pattern.startsWith('/') ? pattern.substring(1) : pattern)
                .filter((pattern) => {
                if (pattern.startsWith('!')) {
                    this.printer.log(`[Sandbox] Pattern ${pattern} found in .gitignore. "${pattern.substring(1)}" will not be watched if other patterns in .gitignore are excluding it.`);
                    return false;
                }
                return true;
            });
        }
        return [];
    };
    /**
     * Checks if a given region has been bootstrapped with >= min version using CDK bootstrap version parameter
     * stored in parameter store.
     * @returns A Boolean that represents if region has been bootstrapped.
     */
    isBootstrapped = async () => {
        try {
            const { Parameter: parameter } = await this.ssmClient.send(new GetParameterCommand({
                Name: CDK_DEFAULT_BOOTSTRAP_VERSION_PARAMETER_NAME,
            }));
            const bootstrapVersion = parameter?.Value;
            if (!bootstrapVersion ||
                Number(bootstrapVersion) < CDK_MIN_BOOTSTRAP_VERSION) {
                return false;
            }
            return true;
        }
        catch (e) {
            if (e instanceof ParameterNotFound) {
                return false;
            }
            if (e instanceof SSMServiceException &&
                [
                    'UnrecognizedClientException',
                    'AccessDeniedException',
                    'NotAuthorized',
                    'ExpiredTokenException',
                    'ExpiredToken',
                    'InvalidSignatureException',
                ].includes(e.name)) {
                throw new AmplifyUserError('SSMCredentialsError', {
                    message: `${e.name}: ${e.message}`,
                    resolution: 'Make sure your AWS credentials are set up correctly and have permissions to call SSM:GetParameter',
                }, e);
            }
            // If we are unable to retrieve bootstrap version parameter due to other reasons, we fail fast.
            throw e;
        }
    };
    /**
     * Generates a printable error message from the thrown error
     */
    getErrorMessage = (error) => {
        let message;
        if (error instanceof Error) {
            message = error.message;
            // Add the downstream exception
            if (error.cause && error.cause instanceof Error && error.cause.message) {
                message = `${message}\nCaused By: ${error.cause.message}\n`;
            }
            if (AmplifyError.isAmplifyError(error) && error.resolution) {
                message = `${message}\nResolution: ${error.resolution}\n`;
            }
        }
        else
            message = String(error);
        return message;
    };
    handleUnsupportedDestructiveChanges = async (options) => {
        this.printer.print(format.error('[Sandbox] We cannot deploy your new changes. You can either revert them or recreate your sandbox with the new changes (deleting all user data)'));
        // offer to recreate the sandbox with new properties
        const answer = await AmplifyPrompter.yesOrNo({
            message: 'Would you like to recreate your sandbox (deleting all user data)?',
            defaultValue: false,
        });
        if (answer) {
            await this.stop();
            await this.reset(options);
        }
        // else let the sandbox continue so customers can revert their changes
    };
    printSandboxNameInfo = async (sandboxIdentifier) => {
        const sandboxBackendId = await this.backendIdSandboxResolver(sandboxIdentifier);
        const stackName = BackendIdentifierConversions.toStackName(sandboxBackendId);
        this.printer.log(format.indent(format.highlight(format.bold('\nAmplify Sandbox\n'))));
        this.printer.log(format.indent(`${format.bold('Identifier:')} \t${sandboxBackendId.name}`));
        this.printer.log(format.indent(`${format.bold('Stack:')} \t${stackName}`));
        if (!sandboxIdentifier) {
            this.printer.log(`${format.indent(format.dim('\nTo specify a different sandbox identifier, use '))}${format.bold('--identifier')}`);
        }
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZV93YXRjaGluZ19zYW5kYm94LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2ZpbGVfd2F0Y2hpbmdfc2FuZGJveC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLFFBQVEsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLEVBQUUsU0FBUyxJQUFJLFVBQVUsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBUzFELE9BQU8sY0FBYyxNQUFNLGlCQUFpQixDQUFDO0FBQzdDLE9BQU8sSUFBSSxNQUFNLE1BQU0sQ0FBQztBQUN4QixPQUFPLEVBQUUsTUFBTSxJQUFJLENBQUM7QUFDcEIsT0FBTyxLQUFLLE1BQU0sTUFBTSxDQUFDO0FBQ3pCLCtEQUErRDtBQUMvRCxnRUFBZ0U7QUFDaEUsT0FBTyxZQUFZLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFDTCxtQkFBbUIsRUFDbkIsaUJBQWlCLEVBRWpCLG1CQUFtQixHQUNwQixNQUFNLHFCQUFxQixDQUFDO0FBQzdCLE9BQU8sRUFDTCxlQUFlLEVBQ2YsUUFBUSxFQUVSLE1BQU0sR0FDUCxNQUFNLHVCQUF1QixDQUFDO0FBQy9CLE9BQU8sRUFFTCx5QkFBeUIsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUNwQyxPQUFPLEVBQ0wsWUFBWSxFQUNaLGdCQUFnQixFQUNoQiw0QkFBNEIsR0FDN0IsTUFBTSw0QkFBNEIsQ0FBQztBQUVwQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sSUFBSSxDQUFDO0FBRXpCOzs7Ozs7Ozs7R0FTRztBQUNILE1BQU0sQ0FBQyxNQUFNLDRDQUE0QztBQUN2RCw4REFBOEQ7QUFDOUQsb0RBQW9EO0FBQ3BELGtDQUFrQyxDQUFDO0FBQ3JDLE1BQU0sQ0FBQyxNQUFNLHlCQUF5QixHQUFHLENBQUMsQ0FBQztBQUUzQzs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0sZUFBZSxHQUFHLENBQUMsTUFBYyxFQUFFLEVBQUUsQ0FDaEQsV0FBVyxN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LHNFQUFzRTtJQUN4RSxDQUFDLENBQUM7SUFFTSxvQkFBb0IsR0FBRyxLQUFLLEVBQUUsaUJBQTBCLEVBQUUsRUFBRTtRQUNsRSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sSUFBSSxDQUFDLHdCQUF3QixDQUMxRCxpQkFBaUIsQ0FDbEIsQ0FBQztRQUNGLE1BQU0sU0FBUyxHQUNiLDRCQUE0QixDQUFDLFdBQVcsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzdELElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUNkLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxDQUNwRSxDQUFDO1FBQ0YsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sZ0JBQWdCLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FDMUUsQ0FBQztRQUNGLElBQUksQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLFNBQVMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMzRSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDdEIsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQ2QsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUNkLE1BQU0sQ0FBQyxHQUFHLENBQUMsbURBQW1ELENBQUMsQ0FDaEUsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxFQUFFLENBQ2xDLENBQUM7U0FDSDtJQUNILENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRlYm91bmNlIGZyb20gJ2RlYm91bmNlLXByb21pc2UnO1xuaW1wb3J0IHsgc3Vic2NyaWJlIGFzIF9zdWJzY3JpYmUgfSBmcm9tICdAcGFyY2VsL3dhdGNoZXInO1xuaW1wb3J0IHsgQW1wbGlmeVNhbmRib3hFeGVjdXRvciB9IGZyb20gJy4vc2FuZGJveF9leGVjdXRvci5qcyc7XG5pbXBvcnQge1xuICBCYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIsXG4gIFNhbmRib3gsXG4gIFNhbmRib3hEZWxldGVPcHRpb25zLFxuICBTYW5kYm94RXZlbnRzLFxuICBTYW5kYm94T3B0aW9ucyxcbn0gZnJvbSAnLi9zYW5kYm94LmpzJztcbmltcG9ydCBwYXJzZUdpdElnbm9yZSBmcm9tICdwYXJzZS1naXRpZ25vcmUnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xuaW1wb3J0IF9vcGVuIGZyb20gJ29wZW4nO1xuLy8gRXZlbnRFbWl0dGVyIGlzIGEgY2xhc3MgbmFtZSBhbmQgZXhwZWN0ZWQgdG8gaGF2ZSBQYXNjYWxDYXNlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQge1xuICBHZXRQYXJhbWV0ZXJDb21tYW5kLFxuICBQYXJhbWV0ZXJOb3RGb3VuZCxcbiAgU1NNQ2xpZW50LFxuICBTU01TZXJ2aWNlRXhjZXB0aW9uLFxufSBmcm9tICdAYXdzLXNkay9jbGllbnQtc3NtJztcbmltcG9ydCB7XG4gIEFtcGxpZnlQcm9tcHRlcixcbiAgTG9nTGV2ZWwsXG4gIFByaW50ZXIsXG4gIGZvcm1hdCxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NsaS1jb3JlJztcbmltcG9ydCB7XG4gIEZpbGVzQ2hhbmdlc1RyYWNrZXIsXG4gIGNyZWF0ZUZpbGVzQ2hhbmdlc1RyYWNrZXIsXG59IGZyb20gJy4vZmlsZXNfY2hhbmdlc190cmFja2VyLmpzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlFcnJvcixcbiAgQW1wbGlmeVVzZXJFcnJvcixcbiAgQmFja2VuZElkZW50aWZpZXJDb252ZXJzaW9ucyxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgTGFtYmRhRnVuY3Rpb25Mb2dTdHJlYW1lciB9IGZyb20gJy4vbGFtYmRhX2Z1bmN0aW9uX2xvZ19zdHJlYW1lci5qcyc7XG5pbXBvcnQgeyBFT0wgfSBmcm9tICdvcyc7XG5cbi8qKlxuICogQ0RLIHN0b3JlcyBib290c3RyYXAgdmVyc2lvbiBpbiBwYXJhbWV0ZXIgc3RvcmUuIEV4YW1wbGUgcGFyYW1ldGVyIG5hbWUgbG9va3MgbGlrZSAvY2RrLWJvb3RzdHJhcC88cXVhbGlmaWVyPi92ZXJzaW9uLlxuICogVGhlIGRlZmF1bHQgdmFsdWUgZm9yIHF1YWxpZmllciBpcyBobmI2NTlmZHMsIGkuZS4gZGVmYXVsdCBwYXJhbWV0ZXIgcGF0aCBpcyAvY2RrLWJvb3RzdHJhcC9obmI2NTlmZHMvdmVyc2lvbi5cbiAqIFRoZSBkZWZhdWx0IHF1YWxpZmllciBpcyBoYXJkY29kZWQgdmFsdWUgd2l0aG91dCBhbnkgc2lnbmlmaWNhbmNlLlxuICogQWJpbGl0eSB0byBwcm92aWRlIGN1c3RvbSBxdWFsaWZpZXIgaXMgaW50ZW5kZWQgZm9yIG5hbWUgaXNvbGF0aW9uIGJldHdlZW4gYXV0b21hdGVkIHRlc3RzIG9mIHRoZSBDREsgaXRzZWxmLlxuICogSW4gb3JkZXIgdG8gdXNlIGN1c3RvbSBxdWFsaWZpZXIgYWxsIHN0YWNrIHN5bnRoZXNpemVycyBtdXN0IGJlIHByb2dyYW1tYXRpY2FsbHkgY29uZmlndXJlZCB0byB1c2UgaXQuXG4gKiBUaGF0IG1ha2VzIGJvb3RzdHJhcHMgd2l0aCBjdXN0b20gcXVhbGlmaWVyIGluY29tcGF0aWJsZSB3aXRoIEFtcGxpZnkgQmFja2VuZCBhbmQgd2UgdHJlYXQgdGhhdCBzZXR1cCBhc1xuICogbm90IGJvb3RzdHJhcHBlZC5cbiAqIFNlZTogaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL2Nkay92Mi9ndWlkZS9ib290c3RyYXBwaW5nLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FID1cbiAgLy8gc3VwcHJlc3Mgc3BlbGwgY2hlY2tlciwgaXQgaXMgdHJpZ2dlcmVkIGJ5IHF1YWxpZmllciB2YWx1ZS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHNwZWxsY2hlY2svc3BlbGwtY2hlY2tlclxuICAnL2Nkay1ib290c3RyYXAvaG5iNjU5ZmRzL3ZlcnNpb24nO1xuZXhwb3J0IGNvbnN0IENES19NSU5fQk9PVFNUUkFQX1ZFUlNJT04gPSA2O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgQW1wbGlmeSBDb25zb2xlIGJvb3RzdHJhcCBVUkwgZm9yIGEgZ2l2ZW4gcmVnaW9uXG4gKiBAcGFyYW0gcmVnaW9uIEFXUyByZWdpb25cbiAqIEByZXR1cm5zIEFtcGxpZnkgQ29uc29sZSBib290c3RyYXAgVVJMXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRCb290c3RyYXBVcmwgPSAocmVnaW9uOiBzdHJpbmcpID0+XG4gIGBodHRwczovLyR7cmVnaW9ufS5jb25zb2xlLmF3cy5hbWF6b24uY29tL2FtcGxpZnkvY3JlYXRlL2Jvb3RzdHJhcD9yZWdpb249JHtyZWdpb259YDtcblxuLyoqXG4gKiBSdW5zIGEgZmlsZSB3YXRjaGVyIGFuZCBkZXBsb3lzXG4gKi9cbmV4cG9ydCBjbGFzcyBGaWxlV2F0Y2hpbmdTYW5kYm94IGV4dGVuZHMgRXZlbnRFbWl0dGVyIGltcGxlbWVudHMgU2FuZGJveCB7XG4gIHByaXZhdGUgd2F0Y2hlclN1YnNjcmlwdGlvbjogQXdhaXRlZDxSZXR1cm5UeXBlPHR5cGVvZiBfc3Vic2NyaWJlPj47XG4gIHByaXZhdGUgb3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaCA9IFsnLmFtcGxpZnknXTtcbiAgcHJpdmF0ZSBmaWxlc0NoYW5nZXNUcmFja2VyOiBGaWxlc0NoYW5nZXNUcmFja2VyO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgd2F0Y2hlciBwcm9jZXNzIGZvciB0aGlzIGluc3RhbmNlXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcjogQmFja2VuZElkU2FuZGJveFJlc29sdmVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZXhlY3V0b3I6IEFtcGxpZnlTYW5kYm94RXhlY3V0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzc21DbGllbnQ6IFNTTUNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZ1bmN0aW9uc0xvZ1N0cmVhbWVyOiBMYW1iZGFGdW5jdGlvbkxvZ1N0cmVhbWVyLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJpbnRlcjogUHJpbnRlcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wZW4gPSBfb3BlbixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN1YnNjcmliZSA9IF9zdWJzY3JpYmVcbiAgKSB7XG4gICAgcHJvY2Vzcy5vbmNlKCdTSUdJTlQnLCAoKSA9PiB2b2lkIHRoaXMuc3RvcCgpKTtcbiAgICBwcm9jZXNzLm9uY2UoJ1NJR1RFUk0nLCAoKSA9PiB2b2lkIHRoaXMuc3RvcCgpKTtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0ZG9jXG4gICAqL1xuICBvdmVycmlkZSBlbWl0KGV2ZW50TmFtZTogU2FuZGJveEV2ZW50cywgLi4uYXJnczogdW5rbm93bltdKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHN1cGVyLmVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgb3ZlcnJpZGUgb24oXG4gICAgZXZlbnROYW1lOiBTYW5kYm94RXZlbnRzLFxuICAgIGxpc3RlbmVyOiAoLi4uYXJnczogdW5rbm93bltdKSA9PiB2b2lkXG4gICk6IHRoaXMge1xuICAgIHJldHVybiBzdXBlci5vbihldmVudE5hbWUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgc3RhcnQgPSBhc3luYyAob3B0aW9uczogU2FuZGJveE9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB3YXRjaERpciA9IG9wdGlvbnMuZGlyID8/ICcuL2FtcGxpZnknO1xuICAgIGNvbnN0IHdhdGNoRm9yQ2hhbmdlcyA9IG9wdGlvbnMud2F0Y2hGb3JDaGFuZ2VzID8/IHRydWU7XG5cbiAgICBpZiAoIWZzLmV4aXN0c1N5bmMod2F0Y2hEaXIpKSB7XG4gICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcignUGF0aE5vdEZvdW5kRXJyb3InLCB7XG4gICAgICAgIG1lc3NhZ2U6IGAke3dhdGNoRGlyfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgICAgICByZXNvbHV0aW9uOlxuICAgICAgICAgICdNYWtlIHN1cmUgeW91IGFyZSBydW5uaW5nIHRoaXMgY29tbWFuZCBmcm9tIHlvdXIgcHJvamVjdCByb290IGRpcmVjdG9yeS4nLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5maWxlc0NoYW5nZXNUcmFja2VyID0gYXdhaXQgY3JlYXRlRmlsZXNDaGFuZ2VzVHJhY2tlcih3YXRjaERpcik7XG4gICAgY29uc3QgYm9vdHN0cmFwcGVkID0gYXdhaXQgdGhpcy5pc0Jvb3RzdHJhcHBlZCgpO1xuICAgIC8vIGdldCByZWdpb24gZnJvbSBhbiBhdmFpbGFibGUgc2RrIGNsaWVudDtcbiAgICBjb25zdCByZWdpb24gPSBhd2FpdCB0aGlzLnNzbUNsaWVudC5jb25maWcucmVnaW9uKCk7XG4gICAgaWYgKCFib290c3RyYXBwZWQpIHtcbiAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgIGBUaGUgcmVnaW9uICR7Zm9ybWF0LmhpZ2hsaWdodChcbiAgICAgICAgICByZWdpb25cbiAgICAgICAgKX0gaGFzIG5vdCBiZWVuIGJvb3RzdHJhcHBlZC4gU2lnbiBpbiB0byB0aGUgQVdTIGNvbnNvbGUgYXMgYSBSb290IHVzZXIgb3IgQWRtaW4gdG8gY29tcGxldGUgdGhlIGJvb3RzdHJhcCBwcm9jZXNzLCB0aGVuIHJlc3RhcnQgdGhlIHNhbmRib3guJHtFT0x9SWYgdGhpcyBpcyBub3QgdGhlIHJlZ2lvbiB5b3UgYXJlIGV4cGVjdGluZyB0byBib290c3RyYXAsIGNoZWNrIGZvciBhbnkgQVdTIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IG1heSBiZSBzZXQgaW4geW91ciBzaGVsbCBvciB1c2UgJHtmb3JtYXQuY29tbWFuZChcbiAgICAgICAgICAnLS1wcm9maWxlIDxwcm9maWxlLW5hbWU+J1xuICAgICAgICApfSB0byBzcGVjaWZ5IGEgcHJvZmlsZSB3aXRoIHRoZSBjb3JyZWN0IHJlZ2lvbi5gXG4gICAgICApO1xuICAgICAgY29uc3QgYm9vdHN0cmFwVXJsID0gZ2V0Qm9vdHN0cmFwVXJsKHJlZ2lvbik7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLm9wZW4oYm9vdHN0cmFwVXJsKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gSWYgb3BlbmluZyB0aGUgbGluayBmYWlscyBmb3IgYW55IHJlYXNvbiB3ZSBmYWxsIGJhY2sgdG9cbiAgICAgICAgLy8gcHJpbnRpbmcgdGhlIHVybCBpbiB0aGUgY29uc29sZS5cbiAgICAgICAgLy8gVGhpcyBtaWdodCBoYXBwZW46XG4gICAgICAgIC8vIC0gaW4gaGVhZGxlc3MgZW52aXJvbm1lbnRzXG4gICAgICAgIC8vIC0gaWYgdXNlciBkb2VzIG5vdCBoYXZlIGFueSBhcHAgdG8gb3BlbiBVUkxcbiAgICAgICAgLy8gLSBpZiBicm93c2VyIGNyYXNoZXNcbiAgICAgICAgbGV0IGxvZ0VudHJ5ID0gJ1VuYWJsZSB0byBvcGVuIGJvb3RzdHJhcCB1cmwnO1xuICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbG9nRW50cnkgPSBgJHtsb2dFbnRyeX0sICR7ZS5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhsb2dFbnRyeSwgTG9nTGV2ZWwuREVCVUcpO1xuICAgICAgICB0aGlzLnByaW50ZXIubG9nKGBPcGVuICR7Ym9vdHN0cmFwVXJsfSBpbiB0aGUgYnJvd3Nlci5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpZ25vcmVkUGF0aHMgPSB0aGlzLmdldEdpdElnbm9yZWRQYXRocygpO1xuICAgIHRoaXMub3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaCA9XG4gICAgICB0aGlzLm91dHB1dEZpbGVzRXhjbHVkZWRGcm9tV2F0Y2guY29uY2F0KC4uLmlnbm9yZWRQYXRocyk7XG5cbiAgICBhd2FpdCB0aGlzLnByaW50U2FuZGJveE5hbWVJbmZvKG9wdGlvbnMuaWRlbnRpZmllcik7XG5cbiAgICAvLyBTaW5jZSAnY2RrIGRlcGxveScgaXMgYSByZWxhdGl2ZWx5IHNsb3cgb3BlcmF0aW9uIGZvciBhICd3YXRjaCcgcHJvY2VzcyxcbiAgICAvLyBpbnRyb2R1Y2UgYSBjb25jdXJyZW5jeSBsYXRjaCB0aGF0IHRyYWNrcyB0aGUgc3RhdGUuXG4gICAgLy8gVGhpcyB3YXksIGlmIGZpbGUgY2hhbmdlIGV2ZW50cyBhcnJpdmUgd2hlbiBhICdjZGsgZGVwbG95JyBpcyBzdGlsbCBleGVjdXRpbmcsXG4gICAgLy8gd2Ugd2lsbCBiYXRjaCB0aGVtLCBhbmQgdHJpZ2dlciBhbm90aGVyICdjZGsgZGVwbG95JyBhZnRlciB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsXG4gICAgLy8gbWFraW5nIHN1cmUgJ2NkayBkZXBsb3kncyAgYWx3YXlzIGV4ZWN1dGUgb25lIGF0IGEgdGltZS5cbiAgICAvLyBIZXJlJ3MgYSBkaWFncmFtIHNob3dpbmcgdGhlIHN0YXRlIHRyYW5zaXRpb25zOlxuXG4gICAgLy8gLS0tLS0tLS0gICAgZmlsZSBjaGFuZ2VkICAgICAtLS0tLS0tLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICBmaWxlIGNoYW5nZWRcbiAgICAvLyB8ICAgICAgfCAtLS0tLS0tLS0tLS0tLS0tLS0+IHwgICAgICAgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS18XG4gICAgLy8gfCBvcGVuIHwgICAgICAgICAgICAgICAgICAgICB8IGRlcGxveWluZyAgfCAgICAgICAgICAgICAgICAgICAgIHwgICBxdWV1ZWQgICB8ICAgICAgICAgICAgICAgfFxuICAgIC8vIHwgICAgICB8IDwtLS0tLS0tLS0tLS0tLS0tLS0gfCAgICAgICAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLXxcbiAgICAvLyAtLS0tLS0tLSAgJ2NkayBkZXBsb3knIGRvbmUgIC0tLS0tLS0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS1cblxuICAgIGxldCBsYXRjaDogJ29wZW4nIHwgJ2RlcGxveWluZycgfCAncXVldWVkJyA9ICdvcGVuJztcblxuICAgIGNvbnN0IGRlcGxveUFuZFdhdGNoID0gZGVib3VuY2UoYXN5bmMgKCkgPT4ge1xuICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcblxuICAgICAgLy8gU3RvcCBzdHJlYW1pbmcgdGhlIGxvZ3Mgc28gdGhhdCBkZXBsb3ltZW50IGxvZ3MgZG9uJ3QgZ2V0IG1peGVkIHVwXG4gICAgICB0aGlzLmZ1bmN0aW9uc0xvZ1N0cmVhbWVyLnN0b3BTdHJlYW1pbmdMb2dzKCk7XG5cbiAgICAgIGF3YWl0IHRoaXMuZGVwbG95KG9wdGlvbnMpO1xuXG4gICAgICAvLyBJZiBsYXRjaCBpcyBzdGlsbCAnZGVwbG95aW5nJyBhZnRlciB0aGUgJ2F3YWl0JywgdGhhdCdzIGZpbmUsXG4gICAgICAvLyBidXQgaWYgaXQncyAncXVldWVkJywgdGhhdCBtZWFucyB3ZSBuZWVkIHRvIGRlcGxveSBhZ2FpblxuICAgICAgd2hpbGUgKChsYXRjaCBhcyAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnKSA9PT0gJ3F1ZXVlZCcpIHtcbiAgICAgICAgLy8gVHlwZVNjcmlwdCBkb2Vzbid0IHJlYWxpemUgbGF0Y2ggY2FuIGNoYW5nZSBiZXR3ZWVuICdhd2FpdHMnIMKvXFxfKOODhClfL8KvLFxuICAgICAgICAvLyBhbmQgdGhpbmtzIHRoZSBhYm92ZSAnd2hpbGUnIGNvbmRpdGlvbiBpcyBhbHdheXMgJ2ZhbHNlJyB3aXRob3V0IHRoZSBjYXN0XG4gICAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgXCJbU2FuZGJveF0gRGV0ZWN0ZWQgZmlsZSBjaGFuZ2VzIHdoaWxlIHByZXZpb3VzIGRlcGxveW1lbnQgd2FzIGluIHByb2dyZXNzLiBJbnZva2luZyAnc2FuZGJveCcgYWdhaW5cIlxuICAgICAgICApO1xuICAgICAgICBhd2FpdCB0aGlzLmRlcGxveShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGxhdGNoID0gJ29wZW4nO1xuXG4gICAgICAvLyBJZGxlIHN0YXRlLCBsZXQgY3VzdG9tZXJzIGtub3cgYW5kIHN0YXJ0IHN0cmVhbWluZyBmdW5jdGlvbiBsb2dzXG4gICAgICB0aGlzLmVtaXRXYXRjaGluZygpO1xuICAgICAgYXdhaXQgdGhpcy5mdW5jdGlvbnNMb2dTdHJlYW1lci5zdGFydFN0cmVhbWluZ0xvZ3MoXG4gICAgICAgIGF3YWl0IHRoaXMuYmFja2VuZElkU2FuZGJveFJlc29sdmVyKG9wdGlvbnMuaWRlbnRpZmllciksXG4gICAgICAgIG9wdGlvbnMuZnVuY3Rpb25TdHJlYW1pbmdPcHRpb25zXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaWYgKHdhdGNoRm9yQ2hhbmdlcykge1xuICAgICAgdGhpcy53YXRjaGVyU3Vic2NyaXB0aW9uID0gYXdhaXQgdGhpcy5zdWJzY3JpYmUoXG4gICAgICAgIHdhdGNoRGlyLFxuICAgICAgICBhc3luYyAoXywgZXZlbnRzKSA9PiB7XG4gICAgICAgICAgLy8gTG9nIGFuZCB0cmFjayBmaWxlIGNoYW5nZXMuXG4gICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBldmVudHMubWFwKCh7IHR5cGU6IGV2ZW50TmFtZSwgcGF0aCB9KSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlci50cmFja0ZpbGVDaGFuZ2UocGF0aCk7XG4gICAgICAgICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgICAgICAgYFtTYW5kYm94XSBUcmlnZ2VyZWQgZHVlIHRvIGEgZmlsZSAke2V2ZW50TmFtZX0gZXZlbnQ6ICR7cGF0aH1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGxhdGNoID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRoaXMgbWVhbnMgbGF0Y2ggaXMgZWl0aGVyICdkZXBsb3lpbmcnIG9yICdxdWV1ZWQnXG4gICAgICAgICAgICBsYXRjaCA9ICdxdWV1ZWQnO1xuICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgJ1tTYW5kYm94XSBQcmV2aW91cyBkZXBsb3ltZW50IGlzIHN0aWxsIGluIHByb2dyZXNzLiAnICtcbiAgICAgICAgICAgICAgICAnV2lsbCBxdWV1ZSBmb3IgYW5vdGhlciBkZXBsb3ltZW50IGFmdGVyIHRoaXMgb25lIGZpbmlzaGVzJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBpZ25vcmU6IHRoaXMub3V0cHV0RmlsZXNFeGNsdWRlZEZyb21XYXRjaC5jb25jYXQoXG4gICAgICAgICAgICAuLi4ob3B0aW9ucy5leGNsdWRlID8/IFtdKVxuICAgICAgICAgICksXG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgICAvLyBTdGFydCB0aGUgZmlyc3QgZnVsbCBkZXBsb3ltZW50IHdpdGhvdXQgd2FpdGluZyBmb3IgYSBmaWxlIGNoYW5nZVxuICAgICAgYXdhaXQgZGVwbG95QW5kV2F0Y2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgdGhpcy5kZXBsb3kob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgc3RvcCA9IGFzeW5jICgpID0+IHtcbiAgICB0aGlzLnByaW50ZXIubG9nKGBbU2FuZGJveF0gU2h1dHRpbmcgZG93bmAsIExvZ0xldmVsLkRFQlVHKTtcbiAgICB0aGlzLmZ1bmN0aW9uc0xvZ1N0cmVhbWVyPy5zdG9wU3RyZWFtaW5nTG9ncygpO1xuICAgIC8vIGNhbiBiZSB1bmRlZmluZWQgaWYgY29tbWFuZCBleGl0cyBiZWZvcmUgc3Vic2NyaXB0aW9uXG4gICAgYXdhaXQgdGhpcy53YXRjaGVyU3Vic2NyaXB0aW9uPy51bnN1YnNjcmliZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdGRvY1xuICAgKi9cbiAgZGVsZXRlID0gYXN5bmMgKG9wdGlvbnM6IFNhbmRib3hEZWxldGVPcHRpb25zKSA9PiB7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICdbU2FuZGJveF0gRGVsZXRpbmcgYWxsIHRoZSByZXNvdXJjZXMgaW4gdGhlIHNhbmRib3ggZW52aXJvbm1lbnQuLi4nXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmV4ZWN1dG9yLmRlc3Ryb3koXG4gICAgICBhd2FpdCB0aGlzLmJhY2tlbmRJZFNhbmRib3hSZXNvbHZlcihvcHRpb25zLmlkZW50aWZpZXIpLFxuICAgICAgb3B0aW9ucy5wcm9maWxlXG4gICAgKTtcbiAgICB0aGlzLmVtaXQoJ3N1Y2Nlc3NmdWxEZWxldGlvbicpO1xuICAgIHRoaXMucHJpbnRlci5sb2coJ1tTYW5kYm94XSBGaW5pc2hlZCBkZWxldGluZy4nKTtcbiAgfTtcblxuICBwcml2YXRlIHNob3VsZFZhbGlkYXRlQXBwU291cmNlcyA9ICgpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBzbmFwc2hvdCA9IHRoaXMuZmlsZXNDaGFuZ2VzVHJhY2tlci5nZXRBbmRSZXNldFNuYXBzaG90KCk7XG4gICAgLy8gaWYgemVybyBmaWxlcyBjaGFuZ2VkIHRoaXMgaW5kaWNhdGVzIGluaXRpYWwgZGVwbG95bWVudFxuICAgIGNvbnN0IHNob3VsZFZhbGlkYXRlT25Db2xkU3RhcnQgPVxuICAgICAgc25hcHNob3QuaGFkVHlwZVNjcmlwdEZpbGVzQXRTdGFydCAmJlxuICAgICAgIXNuYXBzaG90LmRpZEFueUZpbGVDaGFuZ2VTaW5jZVN0YXJ0O1xuICAgIHJldHVybiAoXG4gICAgICBzaG91bGRWYWxpZGF0ZU9uQ29sZFN0YXJ0IHx8XG4gICAgICBzbmFwc2hvdC5kaWRBbnlUeXBlU2NyaXB0RmlsZUNoYW5nZVNpbmNlTGFzdFNuYXBzaG90XG4gICAgKTtcbiAgfTtcblxuICBwcml2YXRlIGRlcGxveSA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZXBsb3lSZXN1bHQgPSBhd2FpdCB0aGlzLmV4ZWN1dG9yLmRlcGxveShcbiAgICAgICAgYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIob3B0aW9ucy5pZGVudGlmaWVyKSxcbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gcGFzcyB0aGlzIGFzIGNhbGxiYWNrIHNvIHRoYXQgZGVib3VuY2UgZG9lc1xuICAgICAgICAvLyBub3QgcmVzZXQgdHJhY2tlciBwcmVtYXR1cmVseVxuICAgICAgICB0aGlzLnNob3VsZFZhbGlkYXRlQXBwU291cmNlcyxcbiAgICAgICAgb3B0aW9ucy5wcm9maWxlXG4gICAgICApO1xuICAgICAgdGhpcy5wcmludGVyLmxvZygnW1NhbmRib3hdIERlcGxveW1lbnQgc3VjY2Vzc2Z1bCcsIExvZ0xldmVsLkRFQlVHKTtcbiAgICAgIHRoaXMuZW1pdCgnc3VjY2Vzc2Z1bERlcGxveW1lbnQnLCBkZXBsb3lSZXN1bHQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBQcmludCBhIG1lYW5pbmdmdWwgbWVzc2FnZVxuICAgICAgdGhpcy5wcmludGVyLnByaW50KGZvcm1hdC5lcnJvcih0aGlzLmdldEVycm9yTWVzc2FnZShlcnJvcikpKTtcbiAgICAgIHRoaXMuZW1pdCgnZmFpbGVkRGVwbG95bWVudCcsIGVycm9yKTtcblxuICAgICAgLy8gSWYgdGhlIGVycm9yIGlzIGJlY2F1c2Ugb2YgYSBub24tYWxsb3dlZCBkZXN0cnVjdGl2ZSBjaGFuZ2Ugc3VjaCBhc1xuICAgICAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXJlc291cmNlLWNvZ25pdG8tdXNlcnBvb2wuaHRtbCNjZm4tY29nbml0by11c2VycG9vbC1hbGlhc2F0dHJpYnV0ZXNcbiAgICAgIC8vIG9mZmVyIHRvIHJlY3JlYXRlIHRoZSBzYW5kYm94IG9yIHJldmVydCB0aGUgY2hhbmdlXG4gICAgICBpZiAoXG4gICAgICAgIEFtcGxpZnlFcnJvci5pc0FtcGxpZnlFcnJvcihlcnJvcikgJiZcbiAgICAgICAgZXJyb3IubmFtZSA9PT0gJ0NGTlVwZGF0ZU5vdFN1cHBvcnRlZEVycm9yJ1xuICAgICAgKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlVW5zdXBwb3J0ZWREZXN0cnVjdGl2ZUNoYW5nZXMob3B0aW9ucyk7XG4gICAgICB9XG4gICAgICAvLyBlbHNlIGRvIG5vdCBwcm9wYWdhdGUgYW5kIGxldCB0aGUgc2FuZGJveCBjb250aW51ZSB0byBydW5cbiAgICB9XG4gIH07XG5cbiAgcHJpdmF0ZSByZXNldCA9IGFzeW5jIChvcHRpb25zOiBTYW5kYm94T3B0aW9ucykgPT4ge1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlKHsgaWRlbnRpZmllcjogb3B0aW9ucy5pZGVudGlmaWVyIH0pO1xuICAgIGF3YWl0IHRoaXMuc3RhcnQob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEp1c3QgYSBzaG9ydGhhbmQgY29uc29sZSBsb2cgdG8gaW5kaWNhdGUgd2hlbmV2ZXIgd2F0Y2hlciBpcyBnb2luZyBpZGxlXG4gICAqL1xuICBwcml2YXRlIGVtaXRXYXRjaGluZyA9ICgpID0+IHtcbiAgICB0aGlzLnByaW50ZXIubG9nKGBbU2FuZGJveF0gV2F0Y2hpbmcgZm9yIGZpbGUgY2hhbmdlcy4uLmApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyBhbmQgcGFyc2VzIC5naXRpZ25vcmUgZmlsZSBhbmQgcmV0dXJucyB0aGUgbGlzdCBvZiBwYXRoc1xuICAgKi9cbiAgcHJpdmF0ZSBnZXRHaXRJZ25vcmVkUGF0aHMgPSAoKSA9PiB7XG4gICAgY29uc3QgZ2l0SWdub3JlRmlsZVBhdGggPSBwYXRoLmpvaW4ocHJvY2Vzcy5jd2QoKSwgJy5naXRpZ25vcmUnKTtcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhnaXRJZ25vcmVGaWxlUGF0aCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUdpdElnbm9yZVxuICAgICAgICAucGFyc2UoZ2l0SWdub3JlRmlsZVBhdGgpXG4gICAgICAgIC5wYXR0ZXJucy5tYXAoKHBhdHRlcm46IHN0cmluZykgPT5cbiAgICAgICAgICBwYXR0ZXJuLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdHRlcm4uc3Vic3RyaW5nKDEpIDogcGF0dGVyblxuICAgICAgICApXG4gICAgICAgIC5maWx0ZXIoKHBhdHRlcm46IHN0cmluZykgPT4ge1xuICAgICAgICAgIGlmIChwYXR0ZXJuLnN0YXJ0c1dpdGgoJyEnKSkge1xuICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgYFtTYW5kYm94XSBQYXR0ZXJuICR7cGF0dGVybn0gZm91bmQgaW4gLmdpdGlnbm9yZS4gXCIke3BhdHRlcm4uc3Vic3RyaW5nKFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKX1cIiB3aWxsIG5vdCBiZSB3YXRjaGVkIGlmIG90aGVyIHBhdHRlcm5zIGluIC5naXRpZ25vcmUgYXJlIGV4Y2x1ZGluZyBpdC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gcmVnaW9uIGhhcyBiZWVuIGJvb3RzdHJhcHBlZCB3aXRoID49IG1pbiB2ZXJzaW9uIHVzaW5nIENESyBib290c3RyYXAgdmVyc2lvbiBwYXJhbWV0ZXJcbiAgICogc3RvcmVkIGluIHBhcmFtZXRlciBzdG9yZS5cbiAgICogQHJldHVybnMgQSBCb29sZWFuIHRoYXQgcmVwcmVzZW50cyBpZiByZWdpb24gaGFzIGJlZW4gYm9vdHN0cmFwcGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBpc0Jvb3RzdHJhcHBlZCA9IGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBQYXJhbWV0ZXI6IHBhcmFtZXRlciB9ID0gYXdhaXQgdGhpcy5zc21DbGllbnQuc2VuZChcbiAgICAgICAgbmV3IEdldFBhcmFtZXRlckNvbW1hbmQoe1xuICAgICAgICAgIE5hbWU6IENES19ERUZBVUxUX0JPT1RTVFJBUF9WRVJTSU9OX1BBUkFNRVRFUl9OQU1FLFxuICAgICAgICB9KVxuICAgICAgKTtcblxuICAgICAgY29uc3QgYm9vdHN0cmFwVmVyc2lvbiA9IHBhcmFtZXRlcj8uVmFsdWU7XG4gICAgICBpZiAoXG4gICAgICAgICFib290c3RyYXBWZXJzaW9uIHx8XG4gICAgICAgIE51bWJlcihib290c3RyYXBWZXJzaW9uKSA8IENES19NSU5fQk9PVFNUUkFQX1ZFUlNJT05cbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFBhcmFtZXRlck5vdEZvdW5kKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChcbiAgICAgICAgZSBpbnN0YW5jZW9mIFNTTVNlcnZpY2VFeGNlcHRpb24gJiZcbiAgICAgICAgW1xuICAgICAgICAgICdVbnJlY29nbml6ZWRDbGllbnRFeGNlcHRpb24nLFxuICAgICAgICAgICdBY2Nlc3NEZW5pZWRFeGNlcHRpb24nLFxuICAgICAgICAgICdOb3RBdXRob3JpemVkJyxcbiAgICAgICAgICAnRXhwaXJlZFRva2VuRXhjZXB0aW9uJyxcbiAgICAgICAgICAnRXhwaXJlZFRva2VuJyxcbiAgICAgICAgICAnSW52YWxpZFNpZ25hdHVyZUV4Y2VwdGlvbicsXG4gICAgICAgIF0uaW5jbHVkZXMoZS5uYW1lKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBBbXBsaWZ5VXNlckVycm9yKFxuICAgICAgICAgICdTU01DcmVkZW50aWFsc0Vycm9yJyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXNzYWdlOiBgJHtlLm5hbWV9OiAke2UubWVzc2FnZX1gLFxuICAgICAgICAgICAgcmVzb2x1dGlvbjpcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB5b3VyIEFXUyBjcmVkZW50aWFscyBhcmUgc2V0IHVwIGNvcnJlY3RseSBhbmQgaGF2ZSBwZXJtaXNzaW9ucyB0byBjYWxsIFNTTTpHZXRQYXJhbWV0ZXInLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB3ZSBhcmUgdW5hYmxlIHRvIHJldHJpZXZlIGJvb3RzdHJhcCB2ZXJzaW9uIHBhcmFtZXRlciBkdWUgdG8gb3RoZXIgcmVhc29ucywgd2UgZmFpbCBmYXN0LlxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHByaW50YWJsZSBlcnJvciBtZXNzYWdlIGZyb20gdGhlIHRocm93biBlcnJvclxuICAgKi9cbiAgcHJpdmF0ZSBnZXRFcnJvck1lc3NhZ2UgPSAoZXJyb3I6IHVua25vd24pID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG5cbiAgICAgIC8vIEFkZCB0aGUgZG93bnN0cmVhbSBleGNlcHRpb25cbiAgICAgIGlmIChlcnJvci5jYXVzZSAmJiBlcnJvci5jYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLmNhdXNlLm1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9XFxuQ2F1c2VkIEJ5OiAke2Vycm9yLmNhdXNlLm1lc3NhZ2V9XFxuYDtcbiAgICAgIH1cblxuICAgICAgaWYgKEFtcGxpZnlFcnJvci5pc0FtcGxpZnlFcnJvcihlcnJvcikgJiYgZXJyb3IucmVzb2x1dGlvbikge1xuICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX1cXG5SZXNvbHV0aW9uOiAke2Vycm9yLnJlc29sdXRpb259XFxuYDtcbiAgICAgIH1cbiAgICB9IGVsc2UgbWVzc2FnZSA9IFN0cmluZyhlcnJvcik7XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIH07XG5cbiAgcHJpdmF0ZSBoYW5kbGVVbnN1cHBvcnRlZERlc3RydWN0aXZlQ2hhbmdlcyA9IGFzeW5jIChcbiAgICBvcHRpb25zOiBTYW5kYm94T3B0aW9uc1xuICApID0+IHtcbiAgICB0aGlzLnByaW50ZXIucHJpbnQoXG4gICAgICBmb3JtYXQuZXJyb3IoXG4gICAgICAgICdbU2FuZGJveF0gV2UgY2Fubm90IGRlcGxveSB5b3VyIG5ldyBjaGFuZ2VzLiBZb3UgY2FuIGVpdGhlciByZXZlcnQgdGhlbSBvciByZWNyZWF0ZSB5b3VyIHNhbmRib3ggd2l0aCB0aGUgbmV3IGNoYW5nZXMgKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpJ1xuICAgICAgKVxuICAgICk7XG4gICAgLy8gb2ZmZXIgdG8gcmVjcmVhdGUgdGhlIHNhbmRib3ggd2l0aCBuZXcgcHJvcGVydGllc1xuICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IEFtcGxpZnlQcm9tcHRlci55ZXNPck5vKHtcbiAgICAgIG1lc3NhZ2U6XG4gICAgICAgICdXb3VsZCB5b3UgbGlrZSB0byByZWNyZWF0ZSB5b3VyIHNhbmRib3ggKGRlbGV0aW5nIGFsbCB1c2VyIGRhdGEpPycsXG4gICAgICBkZWZhdWx0VmFsdWU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGlmIChhbnN3ZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuc3RvcCgpO1xuICAgICAgYXdhaXQgdGhpcy5yZXNldChvcHRpb25zKTtcbiAgICB9XG4gICAgLy8gZWxzZSBsZXQgdGhlIHNhbmRib3ggY29udGludWUgc28gY3VzdG9tZXJzIGNhbiByZXZlcnQgdGhlaXIgY2hhbmdlc1xuICB9O1xuXG4gIHByaXZhdGUgcHJpbnRTYW5kYm94TmFtZUluZm8gPSBhc3luYyAoc2FuZGJveElkZW50aWZpZXI/OiBzdHJpbmcpID0+IHtcbiAgICBjb25zdCBzYW5kYm94QmFja2VuZElkID0gYXdhaXQgdGhpcy5iYWNrZW5kSWRTYW5kYm94UmVzb2x2ZXIoXG4gICAgICBzYW5kYm94SWRlbnRpZmllclxuICAgICk7XG4gICAgY29uc3Qgc3RhY2tOYW1lID1cbiAgICAgIEJhY2tlbmRJZGVudGlmaWVyQ29udmVyc2lvbnMudG9TdGFja05hbWUoc2FuZGJveEJhY2tlbmRJZCk7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgIGZvcm1hdC5pbmRlbnQoZm9ybWF0LmhpZ2hsaWdodChmb3JtYXQuYm9sZCgnXFxuQW1wbGlmeSBTYW5kYm94XFxuJykpKVxuICAgICk7XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgIGZvcm1hdC5pbmRlbnQoYCR7Zm9ybWF0LmJvbGQoJ0lkZW50aWZpZXI6Jyl9IFxcdCR7c2FuZGJveEJhY2tlbmRJZC5uYW1lfWApXG4gICAgKTtcbiAgICB0aGlzLnByaW50ZXIubG9nKGZvcm1hdC5pbmRlbnQoYCR7Zm9ybWF0LmJvbGQoJ1N0YWNrOicpfSBcXHQke3N0YWNrTmFtZX1gKSk7XG4gICAgaWYgKCFzYW5kYm94SWRlbnRpZmllcikge1xuICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgYCR7Zm9ybWF0LmluZGVudChcbiAgICAgICAgICBmb3JtYXQuZGltKCdcXG5UbyBzcGVjaWZ5IGEgZGlmZmVyZW50IHNhbmRib3ggaWRlbnRpZmllciwgdXNlICcpXG4gICAgICAgICl9JHtmb3JtYXQuYm9sZCgnLS1pZGVudGlmaWVyJyl9YFxuICAgICAgKTtcbiAgICB9XG4gIH07XG59XG4iXX0=